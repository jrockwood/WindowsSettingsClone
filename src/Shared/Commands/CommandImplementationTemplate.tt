<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#
    string xmlPath = this.Host.ResolvePath(@"..\..\ServiceContracts\Commands\Commands.xml");
    var root = XElement.Load(xmlPath);

    foreach (XElement command in root.Descendants("command"))
    {
        string commandName = (string)command.Attribute("name");
        string commandDescription = command.Attribute("description")?.Value ?? string.Empty;
        string interfaceName = $"I{commandName}Command";
        string className = $"{commandName}Command";
        string fileName = $"{className}.cs";

        bool hasParameters = command.Descendants("param").Any();
#>
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="<#= fileName #>" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT MODIFY THIS FILE DIRECTLY. It is autogenerated from <#= Path.GetFileName(Host.TemplateFile) #>.

namespace WindowsSettingsClone.Shared.Commands
{
    using System.Collections.Generic;
    using CommandBridge;
    using Diagnostics;
    using ServiceContracts.CommandBridge;
    using ServiceContracts.Commands;

    /// <summary>
    /// <#= commandDescription #>
    /// </summary>
    public sealed class <#= className #> : ServiceCommand, <#= interfaceName #>
    {
        //// ===========================================================================================================
        //// Constructors
        //// ===========================================================================================================

        public <#= className #>(<#= ConstructCtorParameterList(command) #>)
            : base(ServiceCommandName.<#= commandName #>)
        <#= ConstructCtorPropertyAssignmentStatements(command) #>

        internal <#= className #>(BridgeMessageDeserializer deserializer)
            : base(ServiceCommandName.<#= commandName #>)
        <#= ConstructCtorDeserializationStatements(command) #>

<#
        if (hasParameters)
        {
#>
        //// ===========================================================================================================
        //// Properties
        //// ===========================================================================================================

<#
        }

        foreach (XElement param in command.Descendants("param"))
        {
            string paramName = (string)param.Attribute("name");
            string typeName = (string)param.Attribute("type");
#>
        public <#= typeName #> <#= paramName #> { get; }
<#
        }
#>

        //// ===========================================================================================================
        //// Methods
        //// ===========================================================================================================

        internal override void SerializeParams(IDictionary<ParamName, object> valueSet)
        {
<#
        foreach (XElement param in command.Descendants("param"))
        {
            string paramName = (string)param.Attribute("name");
            string typeName = (string)param.Attribute("type");
            string toStringSuffix = IsEnumType(typeName) ? ".ToString()" : "";
#>
            valueSet.Add(ParamName.<#= paramName #>, <#= paramName #><#= toStringSuffix #>);
<#
        }
#>
        }
    }
}
<#
        SaveOutput(fileName);
    }
#>

<#+
private void SaveOutput(string fileName)
{
    string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
    string outputFilePath = Path.Combine(templateDirectory, fileName);
    File.WriteAllText(outputFilePath, GenerationEnvironment.ToString());
    GenerationEnvironment.Remove(0, GenerationEnvironment.Length);
}

private static string ConstructCtorParameterList(XElement command)
{
    var builder = new StringBuilder();

    foreach (XElement param in command.Descendants("param"))
    {
        string paramName = ToCamelCase((string)param.Attribute("name"));
        string typeName = (string)param.Attribute("type");

        if (builder.Length > 0)
        {
            builder.Append(", ");
        }

        builder.Append($"{typeName} {paramName}");
    }

    return builder.ToString();
}

private static string ConstructCtorPropertyAssignmentStatements(XElement command)
{
    var builder = new StringBuilder();
    builder.AppendLine("{");

    foreach (XElement param in command.Descendants("param"))
    {
        string propertyName = (string)param.Attribute("name");
        string paramName = ToCamelCase(propertyName);
        string typeName = (string)param.Attribute("type");
        bool isNullAllowed = bool.Parse(param.Attribute("isNullAllowed")?.Value ?? "false");

        builder.Append(new string(' ', 12));
        builder.Append($"{propertyName} = ");

        if (typeName == "string" && !isNullAllowed)
        {
            builder.Append($"Param.VerifyString({paramName}, nameof({paramName}));");
        }
        else
        {
            builder.Append($"{paramName};");
        }

        builder.AppendLine();
    }

    builder.Append(new string(' ', 8) + "}");
    return builder.ToString();
}

private static string ConstructCtorDeserializationStatements(XElement command)
{
    var builder = new StringBuilder();
    builder.AppendLine("{");

    foreach (XElement param in command.Descendants("param"))
    {
        string paramName = (string)param.Attribute("name");
        string typeName = (string)param.Attribute("type");
        bool isEnum = IsEnumType(typeName);

        string methodCall;
        switch (typeName)
        {
            case "int":
                methodCall = "GetIntValue";
                break;

            case "string":
                methodCall = "GetStringValue";
                break;

            default:
                methodCall = $"GetEnumValue<{typeName}>";
                break;
        }

        builder.Append(new string(' ', 12));
        builder.AppendLine($"{paramName} = deserializer.{methodCall}(ParamName.{paramName});");
    }

    builder.Append(new string(' ', 8) + "}");
    return builder.ToString();
}

private static bool IsEnumType(string typeName)
{
    switch (typeName)
    {
        case "bool":
        case "char":
        case "decimal":
        case "double":
        case "float":
        case "int":
        case "long":
        case "string":
            return false;

        default:
            return true;
    }
}

private static string ToCamelCase(string name)
{
    return char.ToLowerInvariant(name[0]) + name.Substring(1);
}
#>
